{"meta":{"title":"ChenAibing | Blog","subtitle":null,"description":null,"author":"Chen Aibing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-01-24T03:11:26.000Z","updated":"2017-01-24T03:11:26.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Hybrid框架","slug":"Hybrid框架","date":"2017-04-05T02:34:12.000Z","updated":"2017-04-10T03:14:18.000Z","comments":true,"path":"20170405/Hybrid框架/","link":"","permalink":"http://yoursite.com/20170405/Hybrid框架/","excerpt":"Cordova &amp; PhoneGap 入门Apacha Cordova是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。Apacha Cordova是从PhoneGap中抽出的核心代码，是驱动PhoneGap的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。\n\nYou can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. \n\n推荐阅读：PhoneGap, Cordova, and what’s in a name?","text":"Cordova &amp; PhoneGap 入门Apacha Cordova是开源的移动开发框架，允许使用HTML/CSS/JavaScript进行跨平台开发。Apacha Cordova是从PhoneGap中抽出的核心代码，是驱动PhoneGap的核心引擎。目前跨平台开发离不开PhoneGap/Cordova，所以有必要先了解一下。 You can think of Apache Cordova as the engine that powers PhoneGap, similar to how WebKit is the engine that powers Chrome or Safari. 推荐阅读：PhoneGap, Cordova, and what’s in a name? Cordova使用 全局安装cordova。 123456$ sudo npm install -g cordova``` - 用cordova创建项目。```code$ cordova create hello com.example.hello HelloWorld 增加平台platforms。 12345$ cordova platform add ios --save$ cordova platform add android --save// 查看平台$ cordova platform ls 安装构建项目的环境，查看环境要求，之后按照步骤搭建起来。 1234567891011121314$ cordova requirements&gt;&gt;Requirements check results for android:Java JDK: installed 1.8.0Android SDK: installed trueAndroid target: installed android-25Gradle: installed Requirements check results for ios:Apple OS X: installed darwinXcode: installed 8.1ios-deploy: installed 1.9.1CocoaPods: installed 构建项目。 123$ cordova build // 或单独某个平台如IOS$ cordova build ios 安装cordova插件。 123$ cordova plugin add cordova-plugin-camera// 查看项目插件$ cordova plugin ls 重要插件地址: core-plugin-apis更多其他插件: plugreg 创建插件插件必须配置plugin.xml文件，id表示插件名，platform对应当前配置的平台，js-module对应Javascript文件路径，header-file和source-file分别对应.h和.m文件。具体参数可以参考: plugin.xml1$ cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git 可以通过plugman检验当前插件是否能正确安装到各个平台。12$ npm install -g plugman$ plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin 如果要写一个兼容Android/IOS的插件，需要会不同平台的语言，还是有点挑战的。具体的开发方式可以参照官网。发布直接通过npm的方式npm publish的方式即可，记得在发布之前新建package.json文件记录插件的各类信息。 PhoneGapPhoneGap提供了桌面应用和通过phonegap cli来创建/操作项目，同时提供了移动端的调试工具，通过wifi连接即可。 使用 全局安装phonegap。 1$ npm install -g phonegap@latest 创建项目，通过客户端创建相对会慢很多，不指定模板默认phonegap-template-hello-world。 123456$ phonegap create myApp&gt;&gt;Creating a new cordova project.Using cordova-fetch for phonegap-template-hello-world 增加平台platforms和插件plugin的命令和cordova类似，直接用cordova命令也是可以的。但在phonegap项目中在执行添加平台的命令会添加很多的常用的插件，需要等待一段时间，但是很大程度省去了安装插件的操作。 123$ phonegap platform add ios$ phonegap plugin add cordova-plugin-device 将项目拖拽到phonegap客户端界面，可自定义服务的端口，然后手机端连接项目查看效果。或者通过cli开启服务，不需要安装平台(ios/android/.etc)的依赖就可以直接看到效果。 1234$ phonegap serve// 默认端口3000，可通过以下命令改变端口并开启服务phonegap serve --port, -p &lt;n&gt; 调用插件，以拍照为例。 1234567891011121314151617// html&lt;div id=&quot;camera&quot;&gt;拍照&lt;div&gt;// JavaScript// 插件调用都以 `navigator.插件名.方法`var camera = document.getElementById(&apos;camera&apos;);camaraButton.addEventListener(&apos;click&apos;, function()&#123; navigator.camera.getPicture(onLoadImageSuccess, onLoadImageFail);&#125;, false);function onLoadImageSuccess(imageURI)&#123; // 成功返回图片地址 alert(imageURI);&#125;function onLoadImageFail(message)&#123; // 失败返回错误原因 navigator.notification.alert(&quot;拍照失败，原因：&quot; + message, null, &quot;警告&quot;);&#125; 主流Hybrid框架对比OnsenUI提供Angular 1, 2, React 和 Vue.js框架的移动端开发，还需要配合PhoneGap/Cordova实现跨平台开发。 项目地址：https://github.com/OnsenUI/OnsenUI 优势： 文档完善，提供丰富的示例。 提供较多的预定义组件，如Grid、Dialog、Form等常用组件。 提供2套样式，支持Material Design。 提供monaca脚手架，让项目搭建更方便。 多框架语言的支持：React、Angular1/2、Vue2、Meteor。 持续维护，更新及时。 劣势： 不包含但支持PhoneGap/Cordova构建。 推荐指数：🌟🌟🌟🌟🌟 Ionic使用Angular构建跨平台app。 项目地址：https://github.com/driftyco/ionic 优势： 提供Creator非代码环境拖拽组件构建App。 提供丰富的预定义组件，如Grid、Modals、Input、Menus等组件。 提供不同平台的样式选择和修改方式，支持Material Design。 完善的文档，庞大的社区。 劣势： 必须会使用AngularJS去完成复杂的开发。 推荐指数：🌟🌟🌟🌟🌟 Framework 7全功能的HTML框架，用于构建iOS和Android应用程序。针对IOS的UI设计，如果要兼容Android需要另外使用PhoneGap/Cordova。 项目地址：https://github.com/nolimits4web/Framework7/ 优势： 丰富的示例、教程，容易上手。 丰富的组件和插件。 能够轻易和js框架配合使用，如React、Vue。 劣势： 不包含但支持PhoneGap/Cordova构建。 没有提供脚手架，只提供了最基础的服务。 推荐指数：🌟🌟🌟🌟 React Native用React构建跨原生app，和PhoneGap/Cordov原理不一样，性能表现更流畅。 项目地址：https://github.com/facebook/react-native 优势： 仿原生的表现，相对流畅。 庞大的社区。 劣势： 学习曲线陡，需要适当学习客户端开发。 跨平台的兼容性有待考究。 推荐指数：🌟🌟🌟 总结稍微普及了PhoneGap/Cordova，是目前比较成熟和稳定的实现用JavaScript开发的Hybrid框架，但是由于还是通过WebView去展现，所以在性能方面还是不如原生Native来的流畅。 对比当中混入了React Native，其实现原理和PhoneGap/Cordova没什么太大关系。目前很多人用React Native开发项目，从入门到放弃，目前还有太多兼容性和需要自定义的部分，开发成本比预期要来的高，要求开发者不仅会Web的技术，还需要IOS／Android的技术。","raw":null,"content":null,"categories":[],"tags":[{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"},{"name":"hybrid","slug":"hybrid","permalink":"http://yoursite.com/tags/hybrid/"}]},{"title":"webpack性能优化","slug":"webpack性能优化","date":"2017-03-30T02:50:20.000Z","updated":"2017-04-04T13:11:49.000Z","comments":true,"path":"20170330/webpack性能优化/","link":"","permalink":"http://yoursite.com/20170330/webpack性能优化/","excerpt":"Webpack是前端模块加载及资源打包工具。\n\nwebpack takes modules with dependencies and generates static assets representing those modules.\n\n为什么要优化?随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。\n举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。","text":"Webpack是前端模块加载及资源打包工具。 webpack takes modules with dependencies and generates static assets representing those modules. 为什么要优化?随着Webpack的普遍，越来越多的开发者反映构建慢、bundle包大等问题。虽然Webpack可以通过简单的配置完成琐碎的文件编译、打包，但是如果每次改动到看到效果、每次打包完成都需要消耗大量的时间，最终换来一个或多个体积巨大的js文件，开发者对Webpack可能会渐渐失去信心，所以了解Webpack性能优化在所难免。 举个例子，一个业务项目中，一般需要如babel的编译包，如react或其他的底层框架包，如less/sass的样式编译包，如css/style的样式加载包，如文件加载包，当然还有webpack本身，如果配合其他工具还需要gulp/grunt及其插件包，不算测试相关的模块和项目中用到的其它模块，林林总总有10+个模块。花费时间多并不是模块多这个事实，而是处理过程中不同的模块对不同类型且大量的文件搜寻匹配/编译/打包工作。 如何优化?减少安装时间这部分跟Webpack无关，跟开发者的包管理工具和依赖模块有关。 1. 包管理工具npm火了一阵之后开始被各种诟病，npm容易导致在多依赖关系中某些依赖没有指定版本号，导致拉取到的版本不一致，16年10月出了另一个模块管理工具Yarn，yarn可以缓存装过的包实现离线安装，安装速度快，也解决了版本号不确定的问题。 具体关于yarn：Yarn-模块管理工具 2. 依赖模块每次开发完成可以检查一下是不是所有save到package.json以及import/require到文件中的模块都用到了，尽量减少可避免的时间消耗和代码冗余。 除此，确定放在dependencies的依赖是否可以转移到devDependencies中放置，避免增加下载包的大小。 减少build&amp;rebuild时间开发中一般都会开启watch的模式，每一次改动可以即时反映到浏览器上，这部分时间的消耗是至关重要的。 1. babel-loader优化 用exclude或include限制babel编译的文件范围。 babel-loader可以缓存处理过的模块，cacheDirectory对于没有修改过的文件不会再重新编译。 12345&#123; test: /\\.jsx?$/, loaders: [&apos;react-hot&apos;, &apos;babel-loader?cacheDirectory&apos;], exclude: /node_modules/&#125; 2. resolve.root VS resolve.modulesDirectoriesroot是包含你的模块的绝对路径，modulesDirectories是一个目录数组，将解析当前目录及祖先目录，因此，只有在如node_modules的复杂路径下考虑使用modulesDirectories，大部分情景下使用root就足够了。12345resolve:&#123; root: path.resolve(__dirname, &apos;./src&apos;), modulesDirectories: [&apos;node_modules&apos;,&apos;bower_components&apos;], extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]&#125; 3. resolve.aliasalias把用户的一个请求重定向到另一个路径，减少路径搜索的成本。12345resolve:&#123; alias: &#123; xyz: &quot;/absolute/path/to/file.js&quot; &#125;&#125; 4. module.noParsenoParse忽略对已知文件的解析，确定一个模块中没有其它新的依赖 就可以配置这项，webpack 将不再扫描这个文件中的依赖。123module:&#123; noParse:[/jquery/]&#125; 5. DLLPlugin &amp; DllReferencePluginDLLPlugin通过前置依赖包的构建，来提高构建效率。打包dll的时候，Webpack会将所有包含的库做一个索引，写在一个manifest文件中，而引用dll的代码在打包的时候，只需要读取这个manifest文件就可以了。 Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。 首先新建一个dll的配置文件如webpack.dll.config.js，entry只包含第三方库：1234567891011121314151617module.exports = &#123; entry: &#123; // 只包含需要单独打包的依赖包 vendor: [&apos;react&apos;, &apos;react-dom&apos;, &apos;classnames&apos;] &#125;, output: &#123; path: path.join(process.cwd(),&apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos;, library: &apos;[name]_[chunkhash]&apos;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: &apos;manifest.json&apos;, name: &apos;[name]_[chunkhash]&apos;, context: __dirname, &#125;), ],&#125;; 1234567891011// manifest.json &#123; &quot;name&quot;: &quot;vendor_45a4e5523d37b29e930b&quot;, &quot;content&quot;: &#123; &quot;../node_modules/.npminstall/react/0.14.8/react/react.js&quot;: 1, &quot;../node_modules/.npminstall/react/0.14.8/react/lib/React.js&quot;: 2, ... &quot;../node_modules/.npminstall/react-dom/0.14.8/react-dom/index.js&quot;: 158, &quot;../node_modules/.npminstall/classnames/2.2.5/classnames/index.js&quot;: 159 &#125;&#125; 在普通配置文件如webpack.config.js中plugin增加DllReferencePlugin，这里的manifest对应刚刚的manifest.json： 1234567plugins: [ ... new webpack.DllReferencePlugin(&#123; context: __dirname, manifest: require(&apos;./manifest.json&apos;), &#125;), ] 6. happypackhappyPack利用了loader多进程去处理文件，同时还利用缓存来使得重新构建更快。工作流大概如下图： 详细可以参考：happypack 减少bundle包体积1. 提取公共代码块Webpack提供了webpack.optimize.CommonsChunkPlugin的方法，对于多个输出文件之间重复使用的代码，整体减少了bundle包的大小，同时缓存固定依赖。123456789entry: &#123; ... vendor: [&apos;react&apos;, &apos;react-dom&apos;, ...]&#125;,plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: [&apos;vendor&apos;, &apos;manifest&apos;], &#125;),] 2. 文件压缩Webpack提供了UglifyJS来压缩js文件，一般会减少60%左右的体积，有人推荐使用webpack-parallel-uglify-plugin来压缩代码能够得到更快速的体验。 3. 灵活使用externals最近的工作是开发提供给业务的React UI库，之前没有去仔细研究过externals，打包之后发现不压缩的文件有1兆＋，对业务中的模块下载和打包肯定产生一定影响了。认真开始研究性能优化之后发现问题出在react-addons-css-transition-group上，源码只有简单的一句： 1module.exports = require(&apos;react/lib/ReactCSSTransitionGroup&apos;); 把整个react模块又打包进来了，在externals中加入react-addons-css-transition-group之后打包体积剩下300+，非常显著。externals并没有那么智能去判断这个主模块是否已经放在不打包的行列里了，因此如使用到react/lib/ReactDOM也是需要单独列出来。 12345externals:[&#123; &apos;react&apos;: &apos;React&apos;, &apos;react/lib/ReactDOM&apos;: &apos;ReactDOM&apos;, &apos;react-addons-css-transition-group&apos;: &apos;ReactCSSTransitionGroup&apos;&#125;] 另外，externals对应的值需要正确对应当前模块暴露的模块名，否则在通过script引入的情况下无法正常使用：123&lt;script src=&quot;https://npmcdn.com/react@0.14.2/dist/react.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://npmcdn.com/react-dom@0.14.3/dist/react-dom.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./../dist/bundle.js&quot;&gt;&lt;/script&gt; 那么在业务项目中使用的时候，当前模块找不到react相关的依赖会向外在项目的node_modules里面寻找依赖模块。 总结林林总总提了一些优化点，部分是前人总结的优化点。最终还是要针对项目的需求来做优化。 参考：如何 10 倍提高你的 Webpack 构建效率","raw":null,"content":null,"categories":[],"tags":[{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"Promise-JavaScript异步编程","slug":"Promise-JavaScript异步编程","date":"2017-03-05T06:57:24.000Z","updated":"2017-03-06T12:23:24.000Z","comments":true,"path":"20170305/Promise-JavaScript异步编程/","link":"","permalink":"http://yoursite.com/20170305/Promise-JavaScript异步编程/","excerpt":"Promise是异步编程的一种解决方案。\nWhy Promise?Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。\nES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。\n基本用法如下：123456789var promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);\n关于链式写法，借用MDN的图参考如下：\nPromise有三种状态，分别是pending表示初始状态；fulfilled(或resolved)表示操作成功完成；rejected表示操作失败。状态的改变只有2种可能，从pending变成fulfilled以及从pending变成rejected，一旦状态改变，就不会再变。","text":"Promise是异步编程的一种解决方案。 Why Promise?Javascript是单线程执行，因而很多的操作都是异步执行的，其中Ajax就是典型的异步操作。对于异步执行传统的解决方案是回调函数，优点是简单、容易理解和使用，缺点是不利于代码的阅读和维护，代码的高度耦合使得程序结构混乱，多层回调嵌套致使流程难以追踪。 ES2015提供了Promise原生对象，能够为异步代码执行结果的成功和失败分别绑定对应的处理方法，可以采用链式的写法串联多个Promise对象，语法上更明晰。 基本用法如下：123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 关于链式写法，借用MDN的图参考如下： Promise有三种状态，分别是pending表示初始状态；fulfilled(或resolved)表示操作成功完成；rejected表示操作失败。状态的改变只有2种可能，从pending变成fulfilled以及从pending变成rejected，一旦状态改变，就不会再变。 以Ajax为例：123456789101112131415161718var ajax = function(url)&#123; return new Promise(function(resolve, reject)&#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = readyStateHandle; xhr.send(); function readyStateHandle()&#123; if(this.readyState !== 4) return; if(this.status === 200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125; &#125;);&#125; 目前Chrome、Firefox、Safari的高版本已经支持Promise。 Promise API.then()为Promise实例添加状态改变时的回调函数。第一个参数是fulfilled状态的回调函数，即promise被成功完成执行的回调；第二个参数(可选)是rejected状态的回调函数，即promise被拒绝或者出现任何错误、异常的过程中被捕捉到时执行的回调，可以不传对抛出的错误不做处理。 继续上面的Ajax的例子，用法如下：12345ajax(&quot;./posts.json&quot;).then((json) =&gt; &#123; console.log(&apos;Contents:&apos;, json);&#125;, (error) =&gt; &#123; console.error(&apos;出错了&apos;, error);&#125;); then方法返回的是一个新的Promise实例，因此可以使用链式写法。 第一个fulfilled回调函数的返回有2种情况：第一种是返回某个固定的值，将会作为参数传入第二个then方法的fulfilled回调：1234567ajax(&quot;./posts.json&quot;).then(json =&gt; &#123; // 返回一个string return json.nextJsonUrl;&#125;).then( url =&gt; console.log(url), // 得到json.nextJsonUrl对应的值，一个string error =&gt; console.error(&apos;出错了&apos;, error)) 第二种是返回一个Promise对象，则第二个then将会等待当前状态发生变化之后再按照结果决定调用哪个回调：1234567ajax(&quot;./posts.json&quot;).then(json =&gt; &#123; // 返回一个Promise对象 return ajax(json.nextJsonUrl);&#125;).then( nextJson =&gt; console.log(nextJson), // 假设成功，得到第二个json的内容 error =&gt; console.error(&apos;出错了&apos;, error)) .catch()catch方法用于指定发生错误时的回调函数，等同于then(null, rejection)，如下：12345678910ajax(&quot;./posts.json&quot;).then( json =&gt; &#123;...&#125;, error =&gt; console.error(&apos;出错了&apos;, error))// 等同于ajax(&quot;./posts.json&quot;).then( json =&gt; &#123;...&#125;).catch( error =&gt; console.error(&apos;出错了&apos;, error)) 用catch能够捕获ajax()抛出的错误和then方法执行过程中发生的异常或错误，相对then用catch处理rejected状态的写法更佳。 catch方法返回的还是一个Promise对象，因此接下去还可以继续使用then方法。1234567ajax(&quot;./posts.json&quot;).then(json =&gt; &#123; return ajax(json.nextJsonUrl);&#125;).catch( error =&gt; console.error(&apos;出错了&apos;, error)).then( nextJson =&gt; console.log(nextJson)) 如果catch之前没有报错，则直接跳过catch执行下一个then方法，这时候这个then是否报错与前面的catch就无关了。若当前catch方法中抛出错误，在当前catch中是无法捕获的，需要在后面的catch方法中捕获/处理。 .all() &amp; .race()all方法和race方法同样是将多个Promise实力包装成一个新的Promise实例，如果参数非Promise实例，会先通过Promise.resolve方法转化，返回的每个成员都是Promise实例。 对于all方法，只有所有成员都变成fulfilled，promises的状态才会变成fulfilled，这时的返回值组成一个数组传递给promises的回调函数；只要任何一个成员的状态变为rejected，promises的状态就会变成rejected，第一个被rejected的实例的返回值传递给promises的回调函数。12345var promises = Promise.all([p1,p2,p3]).then((posts)=&gt;&#123; console.log(posts); // 假设成功，返回p1,p2,p3返回值的数组&#125;).catch((error)=&gt;&#123; console.error(error); // 假设失败，遍历之后返回第一个失败成员的错误信息&#125;); 对于race方法，只要其中一个成员率先改变状态，就会作为返回值传递给promises的回调函数。123456var promises = Promise.race([p1,p2,p3]).then((posts)=&gt;&#123; console.log(posts); // 假设成功，返回成员中中最开始状态变为fulfilled的返回值&#125;).catch((error)=&gt;&#123; console.error(error); // 假设失败，返回第一个失败成员的错误信息，区别在于只要发现有一个错误马上返回错误&#125;); .resolve()resolve方法用于将传入的参数转化为Promise对象。12345Promise.resolve(&quot;Hello World&quot;);// 等同于new Promise(resolve =&gt; &#123; resolve(&quot;Hello World&quot;);&#125;) 传参可能有四种情况： 参数是一个Promise实例：不做任何改变返回。 参数是一个thenable对象：指的是具有then方法的对象，转为Promise对象，立即执行该对象的then方法。 参数根本不是对象：返回一个状态为Resolved的Promise对象。 不带任何参数：直接返回一个Resolved状态的Promise对象。 .reject()reject方法会返回一个为rejected状态的Promise对象。1234567Promise.reject(&quot;error!&quot;);// 类似于new Promise((resolve, reject) =&gt; &#123; reject(&quot;error!&quot;);&#125;).catch( error =&gt; console.error(error) // 控制台的输出稍有不同) reject方法的参数会原封不动的作为错误的返回值，如：1Promise.reject(ajax(&quot;./posts.json&quot;)); 即使已经成功获取到posts.json的内容，控制台仍然会输出Uncaught (in promise) ...。 总结对Promise的研究还不是很透彻，从表层看，或许只是对传统回调函数写法的一种封装，提供一种更为简单干净的写法；从某些方面看，除此以外，Promise还具有一些相对严谨的特点，如只有异步操作的结果可以决定当前的状态，且状态一旦确定，即使往下再加其它的逻辑，也不会改变当前的结果。 参考：ECMAScript 6入门－Promise对象","raw":null,"content":null,"categories":[{"name":"promise","slug":"promise","permalink":"http://yoursite.com/categories/promise/"},{"name":"异步编程","slug":"promise/异步编程","permalink":"http://yoursite.com/categories/promise/异步编程/"}],"tags":[{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"},{"name":"异步编程","slug":"异步编程","permalink":"http://yoursite.com/tags/异步编程/"}]},{"title":"React组件单元测试","slug":"React组件单元测试","date":"2017-01-18T03:25:02.000Z","updated":"2017-01-24T07:41:09.000Z","comments":true,"path":"20170118/React组件单元测试/","link":"","permalink":"http://yoursite.com/20170118/React组件单元测试/","excerpt":"针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\nTest UtilitiesShallow Rendering - 浅渲染Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。","text":"针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。 Test UtilitiesShallow Rendering - 浅渲染Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。函数shallowRender返回浅渲染的虚拟DOM对象：1234567import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;function shallowRender(Component, props)&#123; const renderer = TestUtils.createRenderer(); renderer.render(&lt;Component &#123;...props&#125;/&gt;); return renderer.getRenderOutput();&#125; 浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：12345678910import React from &apos;react&apos;;import assert from &apos;assert&apos;;import Button from &apos;../src/Button&apos;;describe(&quot;&lt;Button/&gt;&quot;, function()&#123; it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123; const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;); assert(button.props.className.match(&apos;primary&apos;)); &#125;);&#125;); renderIntoDocument - 将element渲染成真实的DOM节点renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：1234567891011121314// ...import &#123;findDOMNode&#125; from &apos;react-dom&apos;;import Switch from &apos;../src/Switch&apos;;describe(&quot;&lt;Switch/&gt;&quot;, function()&#123; it(&apos;改变时触发onChange&apos;, ()=&gt;&#123; let checked = true; const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;); const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0]; TestUtils.Simulate.change(checkbox); assert.equal(checked, false); &#125;);&#125;); 初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。 Simulate - 模拟用户操作Simulate.{eventName}(element,[eventData])将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。123TestUtils.Simulate.click(node);TestUtils.Simulate.change(node);TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;); 节点查找Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对props.children进行查找。 虚拟DOM的节点查找12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.props.children[1].props.children, label);&#125;);// ... checkbox.props.children[1].props.children查找的是第二个子元素的内容。 真实DOM的节点查找对于真实DOM节点，可以是JavaScript原生的一些方法，如findDOMNode(node).querySelector(...)。以下是Test Utilities提供的方法： scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点 findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点 findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 scryRenderedComponentsWithType：找出所有符合指定子组件的节点 findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点 更多信息：Test Utilities EnzymeEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。 使用正式使用前有几点需要注意，否则会报错。 首先，对于webpack的使用者，对于不同的React版本，配置中需要加上： 123456789/* webpack.config.js for React 0.14 */// ...externals: &#123; &apos;cheerio&apos;: &apos;window&apos;, &apos;react/addons&apos;: true, &apos;react/lib/ExecutionEnvironment&apos;: true, &apos;react/lib/ReactContext&apos;: true&#125;// ... 12345678/* webpack.config.js for React 15 */// ...externals: &#123; &apos;react/addons&apos;: true, &apos;react/lib/ExecutionEnvironment&apos;: true, &apos;react/lib/ReactContext&apos;: true&#125;// ... 更多信息：enzyme-guides 针对不同版本React的安装 123/* React 0.13 */npm i react@0.13 --savenpm i --save-dev enzyme 1234/* React 0.14 */npm i --save react@0.14 react-dom@0.14npm i --save-dev react-addons-test-utils@0.14npm i --save-dev enzyme 1234/* React 15 */npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2npm i --save-dev react-addons-test-utils@15.0.0-rc.2npm i --save-dev enzyme 更多信息：enzyme-installation APIshallowshallow方法是对Shallow Rendering的封装，同一个例子，获取className的方法通过props()方法返回。123456// ...it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123; const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;); assert(button.props().className.match(&apos;primary&apos;));&#125;);// ... 同一个例子，使用find()方法查找子节点，text()方法获取文本内容。12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.find(&apos;span&apos;).text(), label);&#125;);// ... mountmount将React组件加载为真实的DOM节点。和shallow的api相同，用find()方法查找子节点，模拟用户操作的方法封装为simulate(enentType)。123456789// ...it(&apos;改变时触发onChange&apos;, ()=&gt;&#123; let checked = true; const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;); switchs.find(&apos;input&apos;).simulate(&apos;change&apos;); assert.equal(checked, false);&#125;);// ... renderrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.find(&apos;span&apos;).text(), label);&#125;);// ... 使用render方法时碰到一个错误：_cheerio2.default.load is not a function，还是比较普遍的，跟webpack配置有关系，修改如下：1234567891011121314externals: &#123; &apos;jsdom&apos;: &apos;window&apos;, // &apos;cheerio&apos;: &apos;window&apos;, // ... &#125;, module:&#123; loaders:[ // ... &#123; test: /\\.json$/, loader: &apos;json&apos;, &#125; ] &#125; 更多信息：enzyme-api 其他JestJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。 Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications. 普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。 更多信息：jest-react-tutorial 总结其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"test","slug":"react/test","permalink":"http://yoursite.com/categories/react/test/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"}]},{"title":"Yarn-模块管理工具","slug":"Yarn-模块管理工具","date":"2017-01-11T11:39:50.000Z","updated":"2017-01-24T07:41:59.000Z","comments":true,"path":"20170111/Yarn-模块管理工具/","link":"","permalink":"http://yoursite.com/20170111/Yarn-模块管理工具/","excerpt":"简介2016年10月11日，facebook发布新的模块管理工具Yarn。随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n允许安装packages时执行代码，埋下安全隐患。\n安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。","text":"简介2016年10月11日，facebook发布新的模块管理工具Yarn。随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如： 安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。 允许安装packages时执行代码，埋下安全隐患。 安装packages的版本不够稳定等。 为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。 Yarn vs NPMyarn.lockNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）： 指定版本号（1.2.2）：只安装指定版本 波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2） 插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2） 当执行npm install [package] --save时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。 yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的npm-shrinkwrap.json，需要通过执行 npm shrinkwrap 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。 更快的模块下载yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。 以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度） 除此，yarn还支持离线下载，前提是之前下过这个包。 对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：1$ yarn config set registry &apos;https://registry.npm.taobao.org&apos; 更简洁的输出yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。 更多信息：migrating-from-npm 使用安装123456// 用Homebrew安装$ brew update$ brew install yarn// 用NPM安装$ npm install yarn -g CLI安装依赖安装package.json的依赖123$ yarnor$ yarn install 本地安装某个模块依赖12345$ yarn add [package] -&gt;$ npm install [package] --save$ yarn add [package] [--dev/-D]-&gt;$ npm install --save-dev [package] 全局安装12$ yarn global add [package]-&gt;$ npm install [--global/-g] [package] 删除依赖12$ yarn remove [package]-&gt;$ npm uninstall --save [package] 升级依赖根据package.json文件重新安装到当前配置的最新版本12$ yarn upgrade-&gt;$ rm -rf node_modules &amp;&amp; npm install 更多与NPM的CLI对比：cli-commands-comparison更多CLI介绍：cli-introduction 其他提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。 总结好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。","raw":null,"content":null,"categories":[{"name":"yarn","slug":"yarn","permalink":"http://yoursite.com/categories/yarn/"},{"name":"npm","slug":"yarn/npm","permalink":"http://yoursite.com/categories/yarn/npm/"},{"name":"工具","slug":"yarn/npm/工具","permalink":"http://yoursite.com/categories/yarn/npm/工具/"}],"tags":[{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"},{"name":"Yarn","slug":"Yarn","permalink":"http://yoursite.com/tags/Yarn/"},{"name":"NPM","slug":"NPM","permalink":"http://yoursite.com/tags/NPM/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"XMLHttpRequest","slug":"XMLHttpRequest","date":"2016-12-30T02:28:11.000Z","updated":"2017-01-24T07:41:20.000Z","comments":true,"path":"20161230/XMLHttpRequest/","link":"","permalink":"http://yoursite.com/20161230/XMLHttpRequest/","excerpt":"","text":"Ajax &amp; XMLHttpRequestajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest发展历程level1缺点： 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”，只能向同一域名的服务器请求数据。 level2改进点： 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 XMLHttpRequest使用1234567891011121314151617181920212223function sendAjax(data) &#123; // 创建xhr对象 var xhr = new XMLHttpRequest(); // 设置xhr请求的超时时间 xhr.timeout = 3000; // 设置响应返回的超时时间 xhr.responseType = &apos;text&apos;; // 创建一个post请求,采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); // 注册相关事件回调处理函数 xhr.onload = function(e)&#123; if(this.status == 200 || this.status == 304)&#123; alert(this.responseText); &#125; &#125;; xhr.ontimeout = function(e) &#123;&#125; xhr.onerror = function(e) &#123;&#125; xhr.upload.onprogress = function(e) &#123;&#125; // 发送数据 xhr.send(data);&#125;","raw":null,"content":null,"categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"React Lifecycle","slug":"react-lifecycle","date":"2016-12-29T07:25:08.000Z","updated":"2017-01-24T07:41:37.000Z","comments":true,"path":"20161229/react-lifecycle/","link":"","permalink":"http://yoursite.com/20161229/react-lifecycle/","excerpt":"","text":"生命周期More Info: Component Specs and Lifecycle 组件渲染经历的生命周期第一次渲染： getDefaultProps getInitialState componentWillMount render componentDidMount 第二次渲染： getInitialState componentWillMount render componentDidMount Props改变时： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate State改变时： shouldComponentUpdate componentWillUpdate render componentDidUpdate 组件卸载时： componentWillUnmont","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}]}