{"meta":{"title":"ChenAibing | Blog","subtitle":null,"description":null,"author":"Chen Aibing","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-01-24T03:11:26.000Z","updated":"2017-01-24T03:11:26.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"React组件单元测试","slug":"React组件单元测试","date":"2017-01-18T03:25:02.000Z","updated":"2017-01-24T07:41:09.000Z","comments":true,"path":"20170118/React组件单元测试/","link":"","permalink":"http://yoursite.com/20170118/React组件单元测试/","excerpt":"针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。\nTest UtilitiesShallow Rendering - 浅渲染Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。","text":"针对react组件的单元测试，facebook提供了Test Utilities测试工具库，Airbnb基于此封装了使用更方便的Enzyme。另外普及一下React的测试框架Jest。 Test UtilitiesShallow Rendering - 浅渲染Shallow rendering是指将组件渲染成虚拟DOM对象，本质上并没有加载进真实DOM，所以并不要求DOM环境，浅渲染只渲染组件的第一层，不涉及所有的子组件，因此在处理速度上非常快。函数shallowRender返回浅渲染的虚拟DOM对象：1234567import TestUtils from &apos;react/lib/ReactTestUtils.js&apos;;function shallowRender(Component, props)&#123; const renderer = TestUtils.createRenderer(); renderer.render(&lt;Component &#123;...props&#125;/&gt;); return renderer.getRenderOutput();&#125; 浅渲染适用于不需要DOM交互，不涉及子组件的情况，如简单验证属性设置是否正确，传值是否正常等。举个例子，验证Button组件phStyle设置为primary是否成功添加到className中：12345678910import React from &apos;react&apos;;import assert from &apos;assert&apos;;import Button from &apos;../src/Button&apos;;describe(&quot;&lt;Button/&gt;&quot;, function()&#123; it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123; const button = shallowRender(&lt;Button phStyle=&apos;primary&apos;&gt;&lt;/Button&gt;); assert(button.props.className.match(&apos;primary&apos;)); &#125;);&#125;); renderIntoDocument - 将element渲染成真实的DOM节点renderIntoDocument将组件实例化，渲染成真实的DOM对象，因此操作环境也是要求必须是真实的DOM环境。渲染成真实DOM之后，可以进行交互，也可以查看子组件的状态。举个例子，验证Switch组件改变时是否触发了onChange：1234567891011121314// ...import &#123;findDOMNode&#125; from &apos;react-dom&apos;;import Switch from &apos;../src/Switch&apos;;describe(&quot;&lt;Switch/&gt;&quot;, function()&#123; it(&apos;改变时触发onChange&apos;, ()=&gt;&#123; let checked = true; const switchs = TestUtils.renderIntoDocument(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;); const checkbox = TestUtils.scryRenderedDOMComponentsWithTag(switchs, &apos;input&apos;)[0]; TestUtils.Simulate.change(checkbox); assert.equal(checked, false); &#125;);&#125;); 初始设置checked为true，由于当前是真实DOM，用到了findDOMNode函数，查找DOM结构中的当前switch节点，手动改变，根据checked数值的对比判断是否执行了onChange。 Simulate - 模拟用户操作Simulate.{eventName}(element,[eventData])将组件渲染进真实DOM中，模拟人为操作，如点击、输入等。123TestUtils.Simulate.click(node);TestUtils.Simulate.change(node);TestUtils.Simulate.keyDown(node, &#123;key: &quot;Enter&quot;, keyCode: 13, which: 13&#125;); 节点查找Test Utilities提供的节点查找的方法仅适用于渲染成真实DOM节点的情况，如果是虚拟DOM是通过对props.children进行查找。 虚拟DOM的节点查找12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = shallowRender(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.props.children[1].props.children, label);&#125;);// ... checkbox.props.children[1].props.children查找的是第二个子元素的内容。 真实DOM的节点查找对于真实DOM节点，可以是JavaScript原生的一些方法，如findDOMNode(node).querySelector(...)。以下是Test Utilities提供的方法： scryRenderedDOMComponentsWithClass：找出所有匹配指定className的节点 findRenderedDOMComponentWithClass：与scryRenderedDOMComponentsWithClass用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 scryRenderedDOMComponentsWithTag：找出所有匹配指定标签的节点 findRenderedDOMComponentWithTag：与scryRenderedDOMComponentsWithTag用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 scryRenderedComponentsWithType：找出所有符合指定子组件的节点 findRenderedComponentWithType：与scryRenderedComponentsWithType用法相同，但只返回一个节点，如有零个或多个匹配的节点就报错 findAllInRenderedTree：遍历当前组件所有的节点，只返回那些符合条件的节点 更多信息：Test Utilities EnzymeEnzyme模拟了JQuery的API封装了一套快速便捷的测试工具库，熟悉JQ的开发者能够更容易上手。 使用正式使用前有几点需要注意，否则会报错。 首先，对于webpack的使用者，对于不同的React版本，配置中需要加上： 123456789/* webpack.config.js for React 0.14 */// ...externals: &#123; &apos;cheerio&apos;: &apos;window&apos;, &apos;react/addons&apos;: true, &apos;react/lib/ExecutionEnvironment&apos;: true, &apos;react/lib/ReactContext&apos;: true&#125;// ... 12345678/* webpack.config.js for React 15 */// ...externals: &#123; &apos;react/addons&apos;: true, &apos;react/lib/ExecutionEnvironment&apos;: true, &apos;react/lib/ReactContext&apos;: true&#125;// ... 更多信息：enzyme-guides 针对不同版本React的安装 123/* React 0.13 */npm i react@0.13 --savenpm i --save-dev enzyme 1234/* React 0.14 */npm i --save react@0.14 react-dom@0.14npm i --save-dev react-addons-test-utils@0.14npm i --save-dev enzyme 1234/* React 15 */npm i --save react@15.0.0-rc.2 react-dom@15.0.0-rc.2npm i --save-dev react-addons-test-utils@15.0.0-rc.2npm i --save-dev enzyme 更多信息：enzyme-installation APIshallowshallow方法是对Shallow Rendering的封装，同一个例子，获取className的方法通过props()方法返回。123456// ...it(&apos;phStyle设置为primary&apos;, ()=&gt;&#123; const button = shallow(&lt;Button phStyle=&apos;primary&apos;&gt;btn&lt;/Button&gt;); assert(button.props().className.match(&apos;primary&apos;));&#125;);// ... 同一个例子，使用find()方法查找子节点，text()方法获取文本内容。12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = shallow(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.find(&apos;span&apos;).text(), label);&#125;);// ... mountmount将React组件加载为真实的DOM节点。和shallow的api相同，用find()方法查找子节点，模拟用户操作的方法封装为simulate(enentType)。123456789// ...it(&apos;改变时触发onChange&apos;, ()=&gt;&#123; let checked = true; const switchs = mount(&lt;Switch checked=&#123;checked&#125; onChange=&#123;()=&gt;&#123;checked=false&#125;&#125; /&gt;); switchs.find(&apos;input&apos;).simulate(&apos;change&apos;); assert.equal(checked, false);&#125;);// ... renderrender方法采用第三方库Cheerio，将React组件渲染成静态的HTML片段并分析其HTML代码结构，返回一个Cheerio实例对象。12345678// ...it(&apos;checkbox: label传值显示正常&apos;, ()=&gt;&#123; let label = &apos;测试&apos;; const checkbox = render(&lt;Input type=&apos;checkbox&apos; label=&#123;label&#125; /&gt;); assert.equal(checkbox.find(&apos;span&apos;).text(), label);&#125;);// ... 使用render方法时碰到一个错误：_cheerio2.default.load is not a function，还是比较普遍的，跟webpack配置有关系，修改如下：1234567891011121314externals: &#123; &apos;jsdom&apos;: &apos;window&apos;, // &apos;cheerio&apos;: &apos;window&apos;, // ... &#125;, module:&#123; loaders:[ // ... &#123; test: /\\.json$/, loader: &apos;json&apos;, &#125; ] &#125; 更多信息：enzyme-api 其他JestJest是facebook基于Jasmine的开发的针对React的单元测试框架。查资料的时候有些文章会对比Enzyme和Jest，让人误以为是同一种东西的不同表达形式，但其实前者是测试工具库，后者是测试框架，更多的时候，两者是配合起来使用的。 Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications. 普及到此为止，有需要之后会研究一下Jest，然后好好写一篇。 更多信息：jest-react-tutorial 总结其实这一篇介绍的东西很少，却写了很多的例子，还记录了一些使用过程中让人困扰的报错。目前测试算是有一套比较完善的机制，但是总的来说东西比较旧比较少，查到的大部分资料都是年份比较久远的。😄","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"},{"name":"test","slug":"react/test","permalink":"http://yoursite.com/categories/react/test/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"},{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"}]},{"title":"Yarn-模块管理工具","slug":"Yarn-模块管理工具","date":"2017-01-11T11:39:50.000Z","updated":"2017-01-24T07:41:59.000Z","comments":true,"path":"20170111/Yarn-模块管理工具/","link":"","permalink":"http://yoursite.com/20170111/Yarn-模块管理工具/","excerpt":"简介2016年10月11日，facebook发布新的模块管理工具Yarn。随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如：\n\n安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。\n允许安装packages时执行代码，埋下安全隐患。\n安装packages的版本不够稳定等。\n\n为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。","text":"简介2016年10月11日，facebook发布新的模块管理工具Yarn。随着NPM的广泛使用中，开始出现安全性和性能不足的问题，如： 安装速度慢（虽然淘宝NPM镜像解决了国内下载慢的现象，但是不可否认使用NPM安装慢的问题）。 允许安装packages时执行代码，埋下安全隐患。 安装packages的版本不够稳定等。 为弥补存在部分缺陷的NPM，facebook和Exponent、Google和Tilde一起打造NPM的替代版本Yarn。 Yarn vs NPMyarn.lockNPM和Yarn都是通过package.json拉取依赖的模块，以下是拉取模块的版本号规则（以1.2.2为例）： 指定版本号（1.2.2）：只安装指定版本 波浪号＋版本号（~1.2,2）：安装1.2.x的最新版本（不低于1.2.2） 插入号＋版本号（^1.2.2）：安装1.x.x的最新版本（不低于1.2.2） 当执行npm install [package] --save时，默认save的是插入号的方式，表示当前的模块至多是向下兼容的功能新增或问题修正。虽然能够手动改成安装指定版本的方式，但也不能确定当前模块依赖的模块是否是固定的，也并不是所有的模块都能按照这样的方式来更新发布，因此每次安装都有可能会拉取到一份版本不固定的模块，这个不稳定性是一个极大的隐患。 yarn.lock锁定文件解决了以上的问题，在执行yarn安装命令时自动生成，确切的记录安装模块的版本号。同样NPM中存在相似的npm-shrinkwrap.json，需要通过执行 npm shrinkwrap 手动生成。对比之下在数据格式上yarn.lock更为精简清晰。 更快的模块下载yarn下载时会进行更好的排序，最大限度的提高网络利用率，且安装过程中如果网络请求失败会进行自动重试。 以下载grunt为例，yarn耗时13.52s，NPM第一次尝试超过一分钟，再次尝试在40s左右。（以上数据跟当前网络状况有相对密切关系，为增加实验可信度，在多次尝试不同的模块的之后，yarn都有相对优异的下载速度） 除此，yarn还支持离线下载，前提是之前下过这个包。 对于安装一整个项目yarn的速度还是需要提升，但是同样也可以给yarn设置安装源：1$ yarn config set registry &apos;https://registry.npm.taobao.org&apos; 更简洁的输出yarn的输出信息添加了一些emoji表情😄，信息简单明了，NPM的输出相对冗长。 更多信息：migrating-from-npm 使用安装123456// 用Homebrew安装$ brew update$ brew install yarn// 用NPM安装$ npm install yarn -g CLI安装依赖安装package.json的依赖123$ yarnor$ yarn install 本地安装某个模块依赖12345$ yarn add [package] -&gt;$ npm install [package] --save$ yarn add [package] [--dev/-D]-&gt;$ npm install --save-dev [package] 全局安装12$ yarn global add [package]-&gt;$ npm install [--global/-g] [package] 删除依赖12$ yarn remove [package]-&gt;$ npm uninstall --save [package] 升级依赖根据package.json文件重新安装到当前配置的最新版本12$ yarn upgrade-&gt;$ rm -rf node_modules &amp;&amp; npm install 更多与NPM的CLI对比：cli-commands-comparison更多CLI介绍：cli-introduction 其他提醒一下，当开始使用yarn要记得将yarn.lock文件一起放进代码仓库中分享给小伙伴，这是准确安装的保证。 总结好像一整篇文章都在赞扬yarn贬低NPM，但是一个东西做出来要让大众接受势必要比前者更加优秀。NPM的强大都见识过了，但问题也是接踵而至，yarn对此做了很多的改善，但是目前看到yarn的issue也是不断，毕竟是新东西，还需要时间的沉淀😄。","raw":null,"content":null,"categories":[{"name":"yarn","slug":"yarn","permalink":"http://yoursite.com/categories/yarn/"},{"name":"npm","slug":"yarn/npm","permalink":"http://yoursite.com/categories/yarn/npm/"},{"name":"工具","slug":"yarn/npm/工具","permalink":"http://yoursite.com/categories/yarn/npm/工具/"}],"tags":[{"name":"陈小饼","slug":"陈小饼","permalink":"http://yoursite.com/tags/陈小饼/"},{"name":"Yarn","slug":"Yarn","permalink":"http://yoursite.com/tags/Yarn/"},{"name":"NPM","slug":"NPM","permalink":"http://yoursite.com/tags/NPM/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"XMLHttpRequest","slug":"XMLHttpRequest","date":"2016-12-30T02:28:11.000Z","updated":"2017-01-24T07:41:20.000Z","comments":true,"path":"20161230/XMLHttpRequest/","link":"","permalink":"http://yoursite.com/20161230/XMLHttpRequest/","excerpt":"","text":"Ajax &amp; XMLHttpRequestajax是一种技术方案,它依赖的是现有的HTML/CSS/Javascript,而其中最核心的依赖是浏览器提供的XMLHttpRequest对象,是这个对象使得浏览器可以发出HTTP请求和接收HTTP响应。即用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest发展历程level1缺点： 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”，只能向同一域名的服务器请求数据。 level2改进点： 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 XMLHttpRequest使用1234567891011121314151617181920212223function sendAjax(data) &#123; // 创建xhr对象 var xhr = new XMLHttpRequest(); // 设置xhr请求的超时时间 xhr.timeout = 3000; // 设置响应返回的超时时间 xhr.responseType = &apos;text&apos;; // 创建一个post请求,采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); // 注册相关事件回调处理函数 xhr.onload = function(e)&#123; if(this.status == 200 || this.status == 304)&#123; alert(this.responseText); &#125; &#125;; xhr.ontimeout = function(e) &#123;&#125; xhr.onerror = function(e) &#123;&#125; xhr.upload.onprogress = function(e) &#123;&#125; // 发送数据 xhr.send(data);&#125;","raw":null,"content":null,"categories":[{"name":"http","slug":"http","permalink":"http://yoursite.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"React Lifecycle","slug":"react-lifecycle","date":"2016-12-29T07:25:08.000Z","updated":"2017-01-24T07:41:37.000Z","comments":true,"path":"20161229/react-lifecycle/","link":"","permalink":"http://yoursite.com/20161229/react-lifecycle/","excerpt":"","text":"生命周期More Info: Component Specs and Lifecycle 组件渲染经历的生命周期第一次渲染： getDefaultProps getInitialState componentWillMount render componentDidMount 第二次渲染： getInitialState componentWillMount render componentDidMount Props改变时： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate State改变时： shouldComponentUpdate componentWillUpdate render componentDidUpdate 组件卸载时： componentWillUnmont","raw":null,"content":null,"categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}]}